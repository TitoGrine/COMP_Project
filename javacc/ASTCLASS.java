import java.util.ArrayList;
import java.util.List;

/* Generated By:JJTree: Do not edit this line. ASTCLASS.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTCLASS extends SimpleNode {
  protected String className;

  public ASTCLASS(int id) {
    super(id);
  }

  public ASTCLASS(Parser p, int id) {
    super(p, id);
  }

  @Override
  public void addSymbolTable(SymbolTable symbolTable){
    this.symbolTable = new SymbolTable(symbolTable);
  }

  @Override
  public void eval(SemanticErrors errors){
    int numChildren = this.jjtGetNumChildren();
    boolean mainDeclared = false;
    int childIndex = 1;

    ASTIDENT firstChild = (ASTIDENT) this.jjtGetChild(0);
    SimpleNode childNode;

    this.className = firstChild.name;

    ClassSymbol classSymbol = new ClassSymbol();
    List<ASTMETHOD> methods = new ArrayList<>();
    ASTMAINMETHOD mainMethod = null;

    if(numChildren > childIndex){
      childNode = (SimpleNode) this.jjtGetChild(childIndex);

      if(childNode.id == ParserTreeConstants.JJTEXTENDS){
        childNode.addSymbolTable(this.symbolTable);
        childNode.eval(errors);

        classSymbol.setExtendedClass(((ASTEXTENDS) childNode).extendedClass);

        childIndex++;
      }
    }

    this.symbolTable.addSymbol(this.className, classSymbol);

    String key;

    while(childIndex < numChildren){
      childNode = (SimpleNode) this.jjtGetChild(childIndex);

      childNode.addSymbolTable(this.symbolTable);

      if (childNode.id == ParserTreeConstants.JJTVARIABLE) {
        ((ASTVARIABLE) childNode).classScope = true;

        childNode.eval(errors);
      } else if (childNode.id == ParserTreeConstants.JJTMETHOD) {
        ASTMETHOD method = (ASTMETHOD) childNode;

        method.preProcessMethod(errors);
        methods.add(method);

        key = className + '.' + method.methodName;

        this.symbolTable.addSymbol(key, method.methodSymbol);
      } else if (childNode.id == ParserTreeConstants.JJTMAINMETHOD){
        if(mainDeclared)
          errors.addError(this.getCoords(), "CLASS " + firstChild.name + " has more than one main method.");

        mainMethod = (ASTMAINMETHOD) childNode;

        mainMethod.preProcessMethod();

        key = className + '.' + mainMethod.methodName;

        this.symbolTable.addSymbol(key, mainMethod.methodSymbol);
        mainDeclared = true;
      }
      childIndex++;
    }

    for(ASTMETHOD method : methods){
      method.eval(errors);
    }

    if(mainMethod != null)
      mainMethod.eval(errors);
  }
}
/* JavaCC - OriginalChecksum=4f01d04b73ea000fe01d2c7f87d2a603 (do not edit this line) */
