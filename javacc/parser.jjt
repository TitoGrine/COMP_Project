options
{
    LOOKAHEAD=1;
    MULTI = true;
}

PARSER_BEGIN(Parser)

import java.io.FileNotFoundException;

public class Parser
{

    private static int nr_errors = 0;
    private static int MAX_ERRORS = 10;

    public static void main(String args[]) throws ParseException {

        Parser grammar;

        if(args.length == 1) {
            try{
                java.io.FileInputStream file = new java.io.FileInputStream(new java.io.File(args[0]));
                grammar = new Parser(file);
            } catch (FileNotFoundException ex) {
                System.out.println(ex);
                return;
            }
        } else {
            grammar = new Parser(System.in);
        }

        SimpleNode root = grammar.Program(); // returns reference to root node

        if (nr_errors > 0) throw new ParseException("Parsing error.");

    }

    void errorSkip(int kind) {
      Token t;
      do {
        t = getNextToken();
      }
      while (t.kind != kind);
    }


    void displayError(ParseException exception) {

        nr_errors++;

        System.out.println("Error occurred. Found " + exception.currentToken.next.image + " in line " +
        exception.currentToken.beginLine + " and column " +
        exception.currentToken.beginColumn);

        System.out.println("Expected one of the tokens:");
        for(int i = 0; i < exception.expectedTokenSequences.length; i++) {
            for(int k = 0; k < exception.expectedTokenSequences[i].length; k++) {
                System.out.println(tokenImage[exception.expectedTokenSequences[i][k]]);
            }
        }

        errorSkip(LBRACKET);

        if (MAX_ERRORS < nr_errors) {
          System.out.println("The program has reached the maximum number of errors (10). Exiting...");
          System.exit(2);
        }
      }

}

PARSER_END(Parser)

// ==================================== SKIP ==================================== //

SKIP :
{
    " "                         |
    "\r"                        |
    "\t"                        |
    "\n"                        |
    < "//" (~["\r", "\n"])* >   |
    "/*" : MULTILINE_COMMENT
}

<MULTILINE_COMMENT> SKIP :
{
  "*/" : DEFAULT                |
  < ~[] >
}

// =================================== TOKENS =================================== //

TOKEN : {
    < LOGICOP: "&&" >           |
    < RELOP: "<" >              |
    < MULT: "*" >               |
    < DIV: "/" >                |
    < SUM: "+" >                |
    < SUB: "-" >                |
    < ASSIGN: "=" >             |
    < NEG: "!" >                        
}

TOKEN :
{
    < IMPORT: "import" >        |
    < CLASS: "class" >          |
    < EXTENDS: "extends" >      |
    < PUBLIC: "public" >        |
    < RETURN: "return" >        |
    < STATIC: "static" >        |
    < VOID: "void" >            |
    < MAIN: "main" >            |
    < NEW: "new" >            
}

TOKEN :
{
    < WHILE: "while" >          |
    < IF: "if" >                |
    < ELSE: "else" >            |
    < TRUE: "true" >            |
    < FALSE: "false" >        
}

TOKEN :
{
    < INT: "int" >              |
    < BOOL: "boolean" >         |
    < STRING: "String" >      
}

TOKEN:
{
    < THIS: "this" >            |
    < LENGTH: "length" >      
}

TOKEN : {
    < COMPLETE: "complete" >
}

TOKEN :
{
    < LBRACKET: "{" >           |
    < RBRACKET: "}" >           |
    < LSQBRACKET: "[" >         |
    < RSQBRACKET: "]" >         |
    < LPRTHSIS: "(">            |
    < RPRTHSIS: ")">            |
    < DOT: "." >                |
    < COMMA: "," >              |
    < SEMICOLON: ";" >        
}

TOKEN: {
    < INTEGERLITERAL: (["0"-"9"])+ >                                                |
    < IDENTIFIER: ["a"-"z","A"-"Z", "$", "_"](["a"-"z","A"-"Z"]|["0"-"9"]|"_")* >
}

// ================================= EXPRESSIONS ================================= //

SimpleNode Program(): {}
{
    ImportDeclaration() ClassDeclaration() <EOF> {return jjtThis;}
}

void ImportDeclaration() #void : {}
{
    (<IMPORT> ImportExpression() <SEMICOLON>)*
}

void ImportExpression() #void : {}
{
    [<STATIC>] <IDENTIFIER> (<DOT> <IDENTIFIER>)* [<LPRTHSIS> [Type() (<COMMA> Type())*] <RPRTHSIS> Type()]
}

void ClassDeclaration() #void : {}
{
    <CLASS> <IDENTIFIER> [<EXTENDS> <IDENTIFIER>] <LBRACKET>
    (VarDeclaration())*
    (MethodDeclaration())*
    <RBRACKET>
}

void VarDeclaration() #void : {}
{
    NonIdentifierVarDeclaration()
    |
    IdentifierVarDeclaration()
}

void NonIdentifierVarDeclaration() #void : {}
{
    NonIdentifierType() <IDENTIFIER> <SEMICOLON>
}

void IdentifierVarDeclaration() #void : {}
{
    <IDENTIFIER> <SEMICOLON>
}

void Type() #void : {}
{
    NonIdentifierType()
    |
    <IDENTIFIER>
}

void NonIdentifierType() #void : {}
{
    <BOOL>
    |
    <INT> [<LSQBRACKET> <RSQBRACKET>]
    |
    <VOID>
}

void MethodDeclaration() #void : {}
{
    <PUBLIC> (RegularMethod() | MainMethod())
}

void RegularMethod() #void : {}
{
    Type() <IDENTIFIER> <LPRTHSIS> [Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*] <RPRTHSIS>
    <LBRACKET>
    MethodBody()
    <RETURN> TerminalExpression() <SEMICOLON>
    <RBRACKET>
}

void MainMethod() #void : {}
{
    <STATIC> <VOID> <MAIN> <LPRTHSIS> <STRING> <LSQBRACKET> <RSQBRACKET> <IDENTIFIER> <RPRTHSIS>
    <LBRACKET>
    MethodBody()
    <RBRACKET>
}

void MethodBody() #void : {}
{
    NonIdentifierVarDeclaration() MethodBody()
    |
    <IDENTIFIER> (IdentifierVarDeclaration() MethodBody() | IdentifierStatements() (Statement())*)
    |
    NonIdentifierStatements() (Statement())*
    |
    {}
}

void Statement() #void : {}
{
    NonIdentifierStatements()
    |
    <IDENTIFIER> IdentifierStatements()
}

void NonIdentifierStatements() #void : {}
{
    EnclosedStatement()
    |
    IfElseStatement()
    |
    WhileStatement()
    |
    ExpressionStatement()
}

void EnclosedStatement() #void : {}
{
    <LBRACKET> (Statement())* <RBRACKET>
}

void IfElseStatement() #void : {}
{
    <IF> <LPRTHSIS> TerminalExpression() <RPRTHSIS> Statement()
    <ELSE> Statement()
}

// void WhileStatement() #void : {}
// {
//     <WHILE> <LPRTHSIS> TerminalExpression() <RPRTHSIS> Statement()
// }


void WhileStatement() #void : {}
{
    <WHILE>

    try {
        <LPRTHSIS> TerminalExpression() <RPRTHSIS>
    } catch(ParseException e) {
        System.out.println("FOUND EXCEPTION");
        displayError(e);
    }
    Statement()
}



void ExpressionStatement() #void : {}
{
    NITerminalExpression() <SEMICOLON>
}

void IdentifierStatements() #void : {}
{
    (AssignStatement() | (ArrayAccess() (AssignStatement() | ComplexExpression())) | NoAccessComplexExpression()) <SEMICOLON>
}

void ArrayAccess() #void : {}
{
    <LSQBRACKET> TerminalExpression() <RSQBRACKET>
}

void AssignStatement() #void : {}
{
   <ASSIGN> TerminalExpression()
}

void ComplexExpression() #void : {}
{
    AccessComplexExpression()
    |
    NoAccessComplexExpression()
}

void AccessComplexExpression() #void : {}
{
    ArrayAccess() ComplexExpression()
}

void NoAccessComplexExpression() #void : {Token t;}
{
    (OperationsPriority1() | OperationsPriority2() | OperationsPriority3()) ComplexExpression()
    |
    <DOT> (<LENGTH> #LENGTH | t = <IDENTIFIER> <LPRTHSIS> [TerminalExpression() (<COMMA> TerminalExpression())*] <RPRTHSIS> {jjtThis.methodID = t.image;} #FUNCMETHOD) ComplexExpression()
    |
    {}
}

void OperationsPriority1() #void : {}
{
    <MULT>    TerminalExpression() /*#MULT(2)*/
    |
    <DIV>     TerminalExpression() /*#DIV(2)*/
}

void OperationsPriority2() #void : {}
{
    <SUM>     TerminalExpression() /*#SUM(2)*/
    |
    <SUB>     TerminalExpression() /*#SUB(2)*/
}

void OperationsPriority3() #void : {}
{
    <LOGICOP> TerminalExpression() /*#AND(2)*/
    |
    <RELOP>   TerminalExpression() /*#LESSTHAN(2)*/
}

void TerminalExpression() #void : {}
{
    NITerminalExpression() | ITerminalExpression()
}

void NITerminalExpression() #void : {Token t;}
{
    t = <INTEGERLITERAL> {jjtThis.value = Integer.parseInt(t.image);} #NUM ComplexExpression()
    |
    t = <TRUE> {jjtThis.truth_value = true;} #BOOL ComplexExpression()
    |
    t = <FALSE> {jjtThis.truth_value = false;} #BOOL ComplexExpression()
    |
    <THIS> #THIS ComplexExpression()
    |
    <NEW> (<INT> <LSQBRACKET> TerminalExpression() <RSQBRACKET> | t=<IDENTIFIER> {} #NEW <LPRTHSIS> <RPRTHSIS>) ComplexExpression()
    |
    <NEG> #NEGATION TerminalExpression() ComplexExpression()
    |
    <LPRTHSIS> TerminalExpression() <RPRTHSIS> ComplexExpression()
}

void ITerminalExpression() #void : {}
{
    <IDENTIFIER> ComplexExpression()
}


