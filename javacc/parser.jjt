options
{
    LOOKAHEAD=1;
    MULTI = true;
}

PARSER_BEGIN(Parser)

import java.io.FileNotFoundException;

public class Parser
{

    private static int nr_errors = 0;
    private static int MAX_ERRORS = 10;

    public static void main(String args[]) throws ParseException {

        Parser grammar;

        if(args.length == 1) {
            try{
                java.io.FileInputStream file = new java.io.FileInputStream(new java.io.File(args[0]));
                grammar = new Parser(file);
            } catch (FileNotFoundException ex) {
                System.out.println(ex);
                return;
            }
        } else {
            grammar = new Parser(System.in);
        }

        SimpleNode root = grammar.Program(); // returns reference to root node



    }

    void errorSkip(int kind) {
      Token t;
      do {
        t = getNextToken();
      }
      while (t.kind != kind);
    }


    void displayError(ParseException e, String condition) {

        nr_errors++;

        System.out.println("Error in " + condition + "condition.\n" + e.toString());

        errorSkip(RPRTHSIS);

        if (MAX_ERRORS < nr_errors) {
          System.out.println("The program has reached the maximum number of errors (10). Exiting...");
          System.exit(2);
        }
      }

}

PARSER_END(Parser)

// ==================================== SKIP ==================================== //

SKIP :
{
    " "                         |
    "\r"                        |
    "\t"                        |
    "\n"                        |
    < "//" (~["\r", "\n"])* >   |
    "/*" : MULTILINE_COMMENT
}

<MULTILINE_COMMENT> SKIP :
{
  "*/" : DEFAULT                |
  < ~[] >
}

// =================================== TOKENS =================================== //

TOKEN : {
    < LOGICOP: "&&" >           |
    < RELOP: "<" >              |
    < MULT: "*" >               |
    < DIV: "/" >                |
    < SUM: "+" >                |
    < SUB: "-" >                |
    < ASSIGN: "=" >             |
    < NEG: "!" >                        
}

TOKEN :
{
    < IMPORT: "import" >        |
    < CLASS: "class" >          |
    < EXTENDS: "extends" >      |
    < PUBLIC: "public" >        |
    < RETURN: "return" >        |
    < STATIC: "static" >        |
    < VOID: "void" >            |
    < MAIN: "main" >            |
    < NEW: "new" >            
}

TOKEN :
{
    < WHILE: "while" >          |
    < IF: "if" >                |
    < ELSE: "else" >            |
    < TRUE: "true" >            |
    < FALSE: "false" >        
}

TOKEN :
{
    < INT: "int" >              |
    < BOOL: "boolean" >         |
    < STRING: "String" >      
}

TOKEN:
{
    < THIS: "this" >            |
    < LENGTH: "length" >      
}

TOKEN :
{
    < LBRACKET: "{" >           |
    < RBRACKET: "}" >           |
    < LSQBRACKET: "[" >         |
    < RSQBRACKET: "]" >         |
    < LPRTHSIS: "(">            |
    < RPRTHSIS: ")">            |
    < DOT: "." >                |
    < COMMA: "," >              |
    < SEMICOLON: ";" >        
}

TOKEN: {
    < INTEGERLITERAL: (["0"-"9"])+ >                                                |
    < IDENTIFIER: ["a"-"z","A"-"Z", "$", "_"](["a"-"z","A"-"Z"]|["0"-"9"]|"_")* >
}

// ================================= EXPRESSIONS ================================= //

SimpleNode Program(): {}
{
    ImportDeclaration() ClassDeclaration() <EOF> {return jjtThis;}
}

void ImportDeclaration() : {}
{
    (<IMPORT> ImportExpression() <SEMICOLON>)*
}

void ImportExpression() #IMPORTEXP : {}
{
    [<STATIC>] Identifier() #LIBRARY (<DOT> Identifier())*  [<LPRTHSIS> [Type() (<COMMA> Type())*] <RPRTHSIS> Type()]
}

void ClassDeclaration() #void : {}
{
    <CLASS> Identifier() [<EXTENDS> Identifier()] <LBRACKET>
    (VarDeclaration())*
    (MethodDeclaration())*
    <RBRACKET>
}

void VarDeclaration() #void : {}
{
    NonIdentifierVarDeclaration()
    |
    IdentifierVarDeclaration()
}

void NonIdentifierVarDeclaration() #void : {}
{
    NonIdentifierType() Identifier() <SEMICOLON>
}

void IdentifierVarDeclaration() #void : {}
{
    Identifier() <SEMICOLON>
}

void Type() #void : {Token t;}
{
    NonIdentifierType()
    |
    Identifier() #TYPE
}

void NonIdentifierType() #void : {}
{
    <BOOL> {jjtThis.typeID = "bool";} #TYPE
    |
    <INT> {jjtThis.typeID = "int";}  #TYPE [<LSQBRACKET> <RSQBRACKET>]
    |
    <VOID> {jjtThis.typeID = "void";} #TYPE
}

void MethodDeclaration()  : {}
{
    <PUBLIC> (RegularMethod() | MainMethod())
}

void RegularMethod() #METHOD : {}
{
    Type() Identifier() <LPRTHSIS> [Type() Identifier() (<COMMA> Type() Identifier())*] <RPRTHSIS>
    <LBRACKET>
    MethodBody()
    <RETURN> TerminalExpression() <SEMICOLON>
    <RBRACKET>
}

void MainMethod() #MAINMETHOD : {}
{
    <STATIC> <VOID> <MAIN> <LPRTHSIS> <STRING> <LSQBRACKET> <RSQBRACKET> Identifier() <RPRTHSIS>
    <LBRACKET>
    MethodBody()
    <RBRACKET>
}

void MethodBody() #void : {}
{
    NonIdentifierVarDeclaration() MethodBody()
    |
    Identifier() (IdentifierVarDeclaration() MethodBody() | IdentifierStatements() (Statement())*)
    |
    NonIdentifierStatements() (Statement())*
    |
    {}
}

void Statement() #void : {}
{
    NonIdentifierStatements()
    |
    Identifier() IdentifierStatements()
}

void NonIdentifierStatements() #void : {}
{
    EnclosedStatement()
    |
    IfElseStatement()
    |
    WhileStatement()
    |
    ExpressionStatement()
}

void EnclosedStatement() #void : {}
{
    <LBRACKET> (Statement())* <RBRACKET>
}

void IfElseStatement() #void : {}
{
    <IF> <LPRTHSIS> TerminalExpression() <RPRTHSIS> Statement()
    <ELSE> Statement()
}

void WhileStatement() #void : {}
{
    <WHILE> <LPRTHSIS> TerminalExpression() <RPRTHSIS> Statement()
}

void ExpressionStatement() #void : {}
{
    NITerminalExpression() <SEMICOLON>
}

void IdentifierStatements() #void : {}
{
    (AssignStatement() | (ArrayAccess() (AssignStatement() | ComplexExpression())) | NoAccessComplexExpression()) <SEMICOLON>
}

void ArrayAccess() #ARRAYACCESS : {}
{
    <LSQBRACKET> TerminalExpression() <RSQBRACKET>
}

void AssignStatement() #ASSIGN : {}
{
    <ASSIGN> TerminalExpression()
}

void ComplexExpression() #void : {}
{
    AccessComplexExpression()
    |
    NoAccessComplexExpression()
}

void ComplexExpressionNoOperators() #void : {}
{
    AccessComplexExpression()
    |
    <DOT> (<LENGTH> #LENGTH | (Identifier()  <LPRTHSIS> [TerminalExpression() (<COMMA> TerminalExpression())*] <RPRTHSIS>) #FUNCMETHOD(2))  ComplexExpression()
    |
    {}
}

void AccessComplexExpression() #void : {}
{
    ArrayAccess() ComplexExpression()
}

void NoAccessComplexExpression() #void : {Token t;}
{
    <DOT> (<LENGTH> #LENGTH | (Identifier()  <LPRTHSIS> [TerminalExpression() (<COMMA> TerminalExpression())*] <RPRTHSIS>) #FUNCMETHOD(2))  ComplexExpression()
    |
    OperationsPriority1() ComplexExpression()
    |
    {}
}

void OperationsPriority1() #void : {}
{
    LOOKAHEAD(2) OperationsPriority2()
    |
    ([OperationsPriority2()] <LOGICOP> TerminalExpression()) #AND(2)
}

void OperationsPriority2() #void : {}
{
    LOOKAHEAD(2) OperationsPriority3()
    |
    ([OperationsPriority3()] <RELOP> TerminalExpressionNoOperators()) #LESSTHAN(2)
}

void OperationsPriority3() #void : {}
{
    LOOKAHEAD(2) OperationsPriority4()
    |
    (<SUM> TerminalExpressionNoOperators() [LOOKAHEAD(2) OperationsPriority3()]) #SUM(2)
    |
    (<SUB> TerminalExpressionNoOperators() [LOOKAHEAD(2) OperationsPriority3()]) #SUB(2)
}

void OperationsPriority4() #void : {}
{
    (LOOKAHEAD(2)(<MULT> TerminalExpressionNoOperators() #MULT(2) | <DIV> TerminalExpressionNoOperators() #DIV(2)))+
}

void TerminalExpression() #void : {}
{
    NITerminalExpression() | ITerminalExpression()
}

void NITerminalExpression() #void : {Token t;}
{
    t = <INTEGERLITERAL> {jjtThis.value = Integer.parseInt(t.image);} #NUM  ComplexExpression()
    |
    t = <TRUE> {jjtThis.truth_value = true;} #BOOL  ComplexExpression()
    |
    t = <FALSE> {jjtThis.truth_value = false;} #BOOL  ComplexExpression()
    |
    <THIS> #THIS  ComplexExpression()
    |
    <NEW> (<INT> <LSQBRACKET> TerminalExpression() <RSQBRACKET> | Identifier() #NEW <LPRTHSIS> <RPRTHSIS>)  ComplexExpression()
    |
    <NEG> #NEGATION TerminalExpression()  ComplexExpression()
    |
    <LPRTHSIS> TerminalExpression() <RPRTHSIS>  ComplexExpression()
}

void TerminalExpressionNoOperators() #void : {Token t;}
{
    t = <INTEGERLITERAL> {jjtThis.value = Integer.parseInt(t.image);} #NUM  ComplexExpressionNoOperators()
    |
    t = <TRUE> {jjtThis.truth_value = true;} #BOOL  ComplexExpressionNoOperators()
    |
    t = <FALSE> {jjtThis.truth_value = false;} #BOOL  ComplexExpressionNoOperators()
    |
    <THIS> #THIS  ComplexExpressionNoOperators()
    |
    <NEW> (<INT> <LSQBRACKET> TerminalExpression() <RSQBRACKET> | Identifier() #NEW <LPRTHSIS> <RPRTHSIS>)  ComplexExpressionNoOperators()
    |
    <NEG> #NEGATION TerminalExpression()  ComplexExpressionNoOperators()
    |
    <LPRTHSIS> TerminalExpression() <RPRTHSIS>  ComplexExpressionNoOperators()
    |
    t = <IDENTIFIER> {jjtThis.name = t.image;} #IDENT ComplexExpressionNoOperators()
}

void ITerminalExpression() #void : {Token t;}
{
    Identifier() ComplexExpression()
}

void Identifier() #void : {Token t;}
{
    t = <IDENTIFIER> {jjtThis.name = t.image;} #IDENT
}


